{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Twitter Compose Rules is a set of custom ktlint rules to ensure that your composables don't fall into common pitfalls, that might be easy to miss in code reviews. Why \u00b6 It can be challenging for big teams to start adopting Compose, particularly because not everyone will start at same time or with the same patterns. Twitter tried to ease the pain by creating a set of Compose static checks. Compose has lots of superpowers but also has a bunch of footguns to be aware of as seen in this Twitter Thread . This is where our static checks come in. We want to detect as many potential issues as we can, as quickly as we can. In this case we want an error to show prior to engineers having to review code. Similar to other static check libraries we hope this leads to a \"don't shoot the messengers\" philosphy which will foster healthy Compose adoption. Using with ktlint \u00b6 You can refer to the Using with ktlint documentation. Using with Detekt \u00b6 You can refer to the Using with Detekt documentation.","title":"Overview"},{"location":"#why","text":"It can be challenging for big teams to start adopting Compose, particularly because not everyone will start at same time or with the same patterns. Twitter tried to ease the pain by creating a set of Compose static checks. Compose has lots of superpowers but also has a bunch of footguns to be aware of as seen in this Twitter Thread . This is where our static checks come in. We want to detect as many potential issues as we can, as quickly as we can. In this case we want an error to show prior to engineers having to review code. Similar to other static check libraries we hope this leads to a \"don't shoot the messengers\" philosphy which will foster healthy Compose adoption.","title":"Why"},{"location":"#using-with-ktlint","text":"You can refer to the Using with ktlint documentation.","title":"Using with ktlint"},{"location":"#using-with-detekt","text":"You can refer to the Using with Detekt documentation.","title":"Using with Detekt"},{"location":"detekt/","text":"When using the Detekt Gradle Plugin , you can specify the dependency on this set of rules by using detektPlugins . dependencies { detektPlugins \"com.twitter.compose.rules:detekt:<VERSION>\" } Using with detekt CLI \u00b6 The releases page contains an uber jar for each version release that can be used to run with the CLI version of detekt . detekt -p detekt-<VERSION>-all.jar -c your/config/detekt.yml Enabling rules \u00b6 For the rules to be picked up, you will need to enable them in your detekt.yml configuration file. TwitterCompose : ContentEmitterReturningValues : active : true ModifierComposable : active : true ModifierMissing : active : true ModifierReused : active : true ModifierWithoutDefault : active : true MultipleEmitters : active : true MutableParams : active : true ComposableNaming : active : true ComposableParamOrder : active : true PreviewPublic : active : true RememberMissing : active : true ViewModelForwarding : active : true ViewModelInjection : active : true Disabling a specific rule \u00b6 To disable a rule you have to follow the instructions from the Detekt documentation , and use the id of the rule you want to disable. For example, to disable ComposableNaming : @Suppress ( \"ComposableNaming\" ) @Composable fun myNameIsWrong () { }","title":"Using with Detekt"},{"location":"detekt/#using-with-detekt-cli","text":"The releases page contains an uber jar for each version release that can be used to run with the CLI version of detekt . detekt -p detekt-<VERSION>-all.jar -c your/config/detekt.yml","title":"Using with detekt CLI"},{"location":"detekt/#enabling-rules","text":"For the rules to be picked up, you will need to enable them in your detekt.yml configuration file. TwitterCompose : ContentEmitterReturningValues : active : true ModifierComposable : active : true ModifierMissing : active : true ModifierReused : active : true ModifierWithoutDefault : active : true MultipleEmitters : active : true MutableParams : active : true ComposableNaming : active : true ComposableParamOrder : active : true PreviewPublic : active : true RememberMissing : active : true ViewModelForwarding : active : true ViewModelInjection : active : true","title":"Enabling rules"},{"location":"detekt/#disabling-a-specific-rule","text":"To disable a rule you have to follow the instructions from the Detekt documentation , and use the id of the rule you want to disable. For example, to disable ComposableNaming : @Suppress ( \"ComposableNaming\" ) @Composable fun myNameIsWrong () { }","title":"Disabling a specific rule"},{"location":"ktlint/","text":"Using with Kotlinter \u00b6 If using kotlinter , you can specify the dependency on this set of rules by using the buildscript classpath . buildscript { dependencies { classpath \"com.twitter.compose.rules:ktlint:<version>\" } } Using with ktlint-gradle \u00b6 Warning : This plugin doesn't currently support ktlint versions over 0.46.0, they are working to support it right now . If using ktlint-gradle , you can specify the dependency on this set of rules by using the ktlintRuleset . dependencies { ktlintRuleset \"com.twitter.compose.rules:ktlint:<VERSION>\" } Using with spotless \u00b6 Warning : If using Spotless , there is no current way of enabling a custom ruleset like ours . You would need to use any of the alternatives listed here (like Kotlinter) to just run these rules. Using with ktlint CLI or the ktlint (unofficial) IntelliJ plugin \u00b6 The releases page contains an uber jar for each version release that can be used for these purposes. To use with ktlint CLI : ktlint -R ktlint-<VERSION>-all.jar You can use this same jar in the ktlint (unofficial) IntelliJ plugin if the rules are compiled against the same ktlint version used for that release. You can configure the custom ruleset in the preferences page of the plugin. Disabling a specific rule \u00b6 To disable a rule you have to follow the instructions from the ktlint documentation , and use the id of the rule you want to disable with the twitter-compose tag. For example, to disable compose-naming-check , the tag you'll need to disable is twitter-compose:compose-naming-check . /* ktlint-disable twitter-compose:compose-naming-check */ ... your code here /* ktlint-enable twitter-compose:compose-naming-check */","title":"Using with ktlint"},{"location":"ktlint/#using-with-kotlinter","text":"If using kotlinter , you can specify the dependency on this set of rules by using the buildscript classpath . buildscript { dependencies { classpath \"com.twitter.compose.rules:ktlint:<version>\" } }","title":"Using with Kotlinter"},{"location":"ktlint/#using-with-ktlint-gradle","text":"Warning : This plugin doesn't currently support ktlint versions over 0.46.0, they are working to support it right now . If using ktlint-gradle , you can specify the dependency on this set of rules by using the ktlintRuleset . dependencies { ktlintRuleset \"com.twitter.compose.rules:ktlint:<VERSION>\" }","title":"Using with ktlint-gradle"},{"location":"ktlint/#using-with-spotless","text":"Warning : If using Spotless , there is no current way of enabling a custom ruleset like ours . You would need to use any of the alternatives listed here (like Kotlinter) to just run these rules.","title":"Using with spotless"},{"location":"ktlint/#using-with-ktlint-cli-or-the-ktlint-unofficial-intellij-plugin","text":"The releases page contains an uber jar for each version release that can be used for these purposes. To use with ktlint CLI : ktlint -R ktlint-<VERSION>-all.jar You can use this same jar in the ktlint (unofficial) IntelliJ plugin if the rules are compiled against the same ktlint version used for that release. You can configure the custom ruleset in the preferences page of the plugin.","title":"Using with ktlint CLI or the ktlint (unofficial) IntelliJ plugin"},{"location":"ktlint/#disabling-a-specific-rule","text":"To disable a rule you have to follow the instructions from the ktlint documentation , and use the id of the rule you want to disable with the twitter-compose tag. For example, to disable compose-naming-check , the tag you'll need to disable is twitter-compose:compose-naming-check . /* ktlint-disable twitter-compose:compose-naming-check */ ... your code here /* ktlint-enable twitter-compose:compose-naming-check */","title":"Disabling a specific rule"},{"location":"rules/","text":"State \u00b6 Hoist all the things \u00b6 Compose is built upon the idea of a unidirectional data flow , which can be summarised as: data/state flows down, and events fire up. To implement that, Compose advocates for the pattern of hoisting state upwards, enabling the majority of your composable functions to be stateless. This has many benefits, including far easier testing. In practice, there are a few common things to look out for: - Do not pass ViewModels (or objects from DI) down. - Do not pass State<Foo> or MutableState<Bar> instances down. Instead pass down the relevant data to the function, and optional lambdas for callbacks. More information: State and Jetpack Compose Related rule: twitter-compose:vm-forwarding-check State should be remembered in composables \u00b6 Be careful when using mutableStateOf (or any of the other state builders) to make sure that you remember the instance. If you don't remember the state instance, a new state instance will be created when the function is recomposed. Related rule: twitter-compose:remember-missing-check Use Immutable annotation whenever possible \u00b6 The Compose Compiler tries to infer immutability and stability on value classes, but sometimes it gets it wrong, which then means that your UI will be doing more work than it needs. To force the compiler to see a class as 'immutable' you can apply the @Immutable annotation to the class. More info: Immutable docs and Composable metrics blog post Related rule: TBD Composables \u00b6 Do not use inherently mutable types as parameters \u00b6 This practice follows on from the 'Hoist all the things' item above, where we said that state flows down. It might be tempting to pass mutable state down to a function to mutate the value. This is an anti-pattern though as it breaks the pattern of state flowing down, and events firing up. The mutation of the value is an event which should be modelled within the function API (a lambda callback). There are a few reasons for this, but the main one is that it is very easy to use a mutable object which does not trigger recomposition. Without triggering recomposition, your composables will not automatically update to reflect the updated value. Passing ArrayList<T> , MutableState<T> , ViewModel are common examples of this (but not limited to those types). Related rule: twitter-compose:mutable-params-check Do not emit content and return a result \u00b6 Composable functions should either emit layout content, or return a value, but not both. If a composable should offer additional control surfaces to its caller, those control surfaces or callbacks should be provided as parameters to the composable function by the caller. More info: Compose API guidelines Related rule: twitter-compose:content-emitter-returning-values-check Do not emit multiple pieces of content \u00b6 A composable function should emit either 0 or 1 pieces of layout, but no more. A composable function should be cohesive, and not rely on what function it is called from. You can see an example of what not to do below. InnerContent() emits a number of layout nodes and assumes that it will be called from a Column: Column { InnerContent () } @Composable private fun InnerContent () { Text (...) Image (...) Button (...) } However InnerContent could just as easily be called from a Row which would break all assumptions. Instead, InnerContent should be cohesive and emit a single layout node itself: @Composable private fun InnerContent () { Column { Text (...) Image (...) Button (...) } } Nesting of layouts has a drastically lower cost vs the view system, so developers should not try to minimize UI layers at the cost of correctness. There is a slight exception to this rule, which is when the function is defined as an extension function of an appropriate scope, like so: @Composable private fun ColumnScope . InnerContent () { Text (...) Image (...) Button (...) } This effectively ties the function to be called from a Column, but is still not recommended (although permitted). Related rule: twitter-compose:multiple-emitters-check Naming @Composable functions properly \u00b6 Composable functions that return Unit should start with an uppercase letter. They are considered declarative entities that can be either present or absent in a composition and therefore follow the naming rules for classes. However, Composable functions that return a value should start with a lowercase letter instead. They should follow the standard Kotlin Coding Conventions for the naming of functions for any function annotated @Composable that returns a value other than Unit More information: Naming Unit @Composable functions as entities and Naming @Composable functions that return values Related rule: twitter-compose:naming-check Ordering @Composable parameters properly \u00b6 When writing Kotlin, it's a good practice to write the parameters for your methods by putting the mandatory parameters first, followed by the optional ones (aka the ones with default values). By doing so, we minimize the number times we will need to write the name for arguments explicitly . Modifiers occupy the first optional parameter slot to set a consistent expectation for developers that they can always provide a modifier as the final positional parameter to an element call for any given element's common case. More information: Kotlin default arguments , Modifier docs and Elements accept and respect a Modifier parameter . Related rule: twitter-compose:param-order-check Make dependencies explicit \u00b6 When designing our composables, we should always try to be explicit about the dependencies they take in. If you acquire a ViewModel or an instance from DI in the body of the composable, you are making this dependency implicit, which has the downsides of making it hard to test and harder to reuse. To solve this problem, you should inject these dependencies as default values in the composable function. Let's see it with an example. @Composable private fun MyComposable () { val viewModel = viewModel < MyViewModel > () // ... } In this composable, the dependencies are implicit. When testing it you would need to fake the internals of viewModel somehow to be able to acquire your intended ViewModel. But, if you change it to pass these instances via the composable function parameters, you could provide the instance you want directly in your tests without any extra effort. It would also have the upside of the function being explicit about its external dependencies in its signature. @Composable private fun MyComposable ( viewModel : MyViewModel = viewModel (), ) { // ... } Related rule: twitter-compose:vm-injection-check Preview composables should not be public \u00b6 When a composable function exists solely because it's a @Preview , it doesn't need to have public visibility because it won't be used in actual UI. To prevent folks from using it unknowingly, we should restrict its visibility to private . Related rule: twitter-compose:preview-public-check NOTE : If you are using Detekt, this may conflict with Detekt's UnusedPrivateMember rule . Be sure to set Detekt's ignoreAnnotated configuration to ['Preview'] for compatibility with this rule. Modifiers \u00b6 When should I expose modifier parameters? \u00b6 Modifiers are the beating heart of Compose UI. They encapsulate the idea of composition over inheritance, by allowing developers to attach logic and behavior to layouts. They are especially important for your public components, as they allow callers to customize the component to their wishes. More info: Always provide a Modifier parameter Related rule: twitter-compose:modifier-missing-check Don't re-use modifiers \u00b6 Modifiers which are passed in are designed so that they should be used by a single layout node in the composable function. If the provided modifier is used by multiple composables at different levels, unwanted behaviour can happen. In the following example we've exposed a public modifier parameter, and then passed it to the root Column, but we've also passed it to each of the descendant calls, with some extra modifiers on top: @Composable private fun InnerContent ( modifier : Modifier = Modifier ) { Column ( modifier ) { Text ( modifier . clickable (), ...) Image ( modifier . size (), ...) Button ( modifier , ...) } } This is not recommended. Instead, the provided modifier should only be used on the Column. The descendant calls should use newly built modifiers, by using the empty Modifier object: @Composable private fun InnerContent ( modifier : Modifier = Modifier ) { Column ( modifier ) { Text ( Modifier . clickable (), ...) Image ( Modifier . size (), ...) Button ( Modifier , ...) } } Related rule: twitter-compose:modifier-reused-check Modifiers should have default parameters \u00b6 Composables that accept a Modifier as a parameter to be applied to the whole component represented by the composable function should name the parameter modifier and assign the parameter a default value of Modifier . It should appear as the first optional parameter in the parameter list; after all required parameters (except for trailing lambda parameters) but before any other parameters with default values. Any default modifiers desired by a composable function should come after the modifier parameter's value in the composable function's implementation, keeping Modifier as the default parameter value. More info: Modifier documentation Related rule: twitter-compose:modifier-without-default-check Avoid Modifier extension factory functions \u00b6 Using @Composable builder functions for modifiers is not recommended, as they cause unnecessary recompositions. To avoid this, you should use Modifier.composed instead, as it limits recomposition to just the modifier instance, rather than the whole function tree. Composed modifiers may be created outside of composition, shared across elements, and declared as top-level constants, making them more flexible than modifiers that can only be created via a @Composable function call, and easier to avoid accidentally sharing state across elements. More info: Modifier extensions , Composed modifiers in Jetpack Compose by Jorge Castillo and Composed modifiers in API guidelines Related rule: twitter-compose:modifier-composable-check","title":"Ruleset"},{"location":"rules/#state","text":"","title":"State"},{"location":"rules/#hoist-all-the-things","text":"Compose is built upon the idea of a unidirectional data flow , which can be summarised as: data/state flows down, and events fire up. To implement that, Compose advocates for the pattern of hoisting state upwards, enabling the majority of your composable functions to be stateless. This has many benefits, including far easier testing. In practice, there are a few common things to look out for: - Do not pass ViewModels (or objects from DI) down. - Do not pass State<Foo> or MutableState<Bar> instances down. Instead pass down the relevant data to the function, and optional lambdas for callbacks. More information: State and Jetpack Compose Related rule: twitter-compose:vm-forwarding-check","title":"Hoist all the things"},{"location":"rules/#state-should-be-remembered-in-composables","text":"Be careful when using mutableStateOf (or any of the other state builders) to make sure that you remember the instance. If you don't remember the state instance, a new state instance will be created when the function is recomposed. Related rule: twitter-compose:remember-missing-check","title":"State should be remembered in composables"},{"location":"rules/#use-immutable-annotation-whenever-possible","text":"The Compose Compiler tries to infer immutability and stability on value classes, but sometimes it gets it wrong, which then means that your UI will be doing more work than it needs. To force the compiler to see a class as 'immutable' you can apply the @Immutable annotation to the class. More info: Immutable docs and Composable metrics blog post Related rule: TBD","title":"Use Immutable annotation whenever possible"},{"location":"rules/#composables","text":"","title":"Composables"},{"location":"rules/#do-not-use-inherently-mutable-types-as-parameters","text":"This practice follows on from the 'Hoist all the things' item above, where we said that state flows down. It might be tempting to pass mutable state down to a function to mutate the value. This is an anti-pattern though as it breaks the pattern of state flowing down, and events firing up. The mutation of the value is an event which should be modelled within the function API (a lambda callback). There are a few reasons for this, but the main one is that it is very easy to use a mutable object which does not trigger recomposition. Without triggering recomposition, your composables will not automatically update to reflect the updated value. Passing ArrayList<T> , MutableState<T> , ViewModel are common examples of this (but not limited to those types). Related rule: twitter-compose:mutable-params-check","title":"Do not use inherently mutable types as parameters"},{"location":"rules/#do-not-emit-content-and-return-a-result","text":"Composable functions should either emit layout content, or return a value, but not both. If a composable should offer additional control surfaces to its caller, those control surfaces or callbacks should be provided as parameters to the composable function by the caller. More info: Compose API guidelines Related rule: twitter-compose:content-emitter-returning-values-check","title":"Do not emit content and return a result"},{"location":"rules/#do-not-emit-multiple-pieces-of-content","text":"A composable function should emit either 0 or 1 pieces of layout, but no more. A composable function should be cohesive, and not rely on what function it is called from. You can see an example of what not to do below. InnerContent() emits a number of layout nodes and assumes that it will be called from a Column: Column { InnerContent () } @Composable private fun InnerContent () { Text (...) Image (...) Button (...) } However InnerContent could just as easily be called from a Row which would break all assumptions. Instead, InnerContent should be cohesive and emit a single layout node itself: @Composable private fun InnerContent () { Column { Text (...) Image (...) Button (...) } } Nesting of layouts has a drastically lower cost vs the view system, so developers should not try to minimize UI layers at the cost of correctness. There is a slight exception to this rule, which is when the function is defined as an extension function of an appropriate scope, like so: @Composable private fun ColumnScope . InnerContent () { Text (...) Image (...) Button (...) } This effectively ties the function to be called from a Column, but is still not recommended (although permitted). Related rule: twitter-compose:multiple-emitters-check","title":"Do not emit multiple pieces of content"},{"location":"rules/#naming-composable-functions-properly","text":"Composable functions that return Unit should start with an uppercase letter. They are considered declarative entities that can be either present or absent in a composition and therefore follow the naming rules for classes. However, Composable functions that return a value should start with a lowercase letter instead. They should follow the standard Kotlin Coding Conventions for the naming of functions for any function annotated @Composable that returns a value other than Unit More information: Naming Unit @Composable functions as entities and Naming @Composable functions that return values Related rule: twitter-compose:naming-check","title":"Naming @Composable functions properly"},{"location":"rules/#ordering-composable-parameters-properly","text":"When writing Kotlin, it's a good practice to write the parameters for your methods by putting the mandatory parameters first, followed by the optional ones (aka the ones with default values). By doing so, we minimize the number times we will need to write the name for arguments explicitly . Modifiers occupy the first optional parameter slot to set a consistent expectation for developers that they can always provide a modifier as the final positional parameter to an element call for any given element's common case. More information: Kotlin default arguments , Modifier docs and Elements accept and respect a Modifier parameter . Related rule: twitter-compose:param-order-check","title":"Ordering @Composable parameters properly"},{"location":"rules/#make-dependencies-explicit","text":"When designing our composables, we should always try to be explicit about the dependencies they take in. If you acquire a ViewModel or an instance from DI in the body of the composable, you are making this dependency implicit, which has the downsides of making it hard to test and harder to reuse. To solve this problem, you should inject these dependencies as default values in the composable function. Let's see it with an example. @Composable private fun MyComposable () { val viewModel = viewModel < MyViewModel > () // ... } In this composable, the dependencies are implicit. When testing it you would need to fake the internals of viewModel somehow to be able to acquire your intended ViewModel. But, if you change it to pass these instances via the composable function parameters, you could provide the instance you want directly in your tests without any extra effort. It would also have the upside of the function being explicit about its external dependencies in its signature. @Composable private fun MyComposable ( viewModel : MyViewModel = viewModel (), ) { // ... } Related rule: twitter-compose:vm-injection-check","title":"Make dependencies explicit"},{"location":"rules/#preview-composables-should-not-be-public","text":"When a composable function exists solely because it's a @Preview , it doesn't need to have public visibility because it won't be used in actual UI. To prevent folks from using it unknowingly, we should restrict its visibility to private . Related rule: twitter-compose:preview-public-check NOTE : If you are using Detekt, this may conflict with Detekt's UnusedPrivateMember rule . Be sure to set Detekt's ignoreAnnotated configuration to ['Preview'] for compatibility with this rule.","title":"Preview composables should not be public"},{"location":"rules/#modifiers","text":"","title":"Modifiers"},{"location":"rules/#when-should-i-expose-modifier-parameters","text":"Modifiers are the beating heart of Compose UI. They encapsulate the idea of composition over inheritance, by allowing developers to attach logic and behavior to layouts. They are especially important for your public components, as they allow callers to customize the component to their wishes. More info: Always provide a Modifier parameter Related rule: twitter-compose:modifier-missing-check","title":"When should I expose modifier parameters?"},{"location":"rules/#dont-re-use-modifiers","text":"Modifiers which are passed in are designed so that they should be used by a single layout node in the composable function. If the provided modifier is used by multiple composables at different levels, unwanted behaviour can happen. In the following example we've exposed a public modifier parameter, and then passed it to the root Column, but we've also passed it to each of the descendant calls, with some extra modifiers on top: @Composable private fun InnerContent ( modifier : Modifier = Modifier ) { Column ( modifier ) { Text ( modifier . clickable (), ...) Image ( modifier . size (), ...) Button ( modifier , ...) } } This is not recommended. Instead, the provided modifier should only be used on the Column. The descendant calls should use newly built modifiers, by using the empty Modifier object: @Composable private fun InnerContent ( modifier : Modifier = Modifier ) { Column ( modifier ) { Text ( Modifier . clickable (), ...) Image ( Modifier . size (), ...) Button ( Modifier , ...) } } Related rule: twitter-compose:modifier-reused-check","title":"Don't re-use modifiers"},{"location":"rules/#modifiers-should-have-default-parameters","text":"Composables that accept a Modifier as a parameter to be applied to the whole component represented by the composable function should name the parameter modifier and assign the parameter a default value of Modifier . It should appear as the first optional parameter in the parameter list; after all required parameters (except for trailing lambda parameters) but before any other parameters with default values. Any default modifiers desired by a composable function should come after the modifier parameter's value in the composable function's implementation, keeping Modifier as the default parameter value. More info: Modifier documentation Related rule: twitter-compose:modifier-without-default-check","title":"Modifiers should have default parameters"},{"location":"rules/#avoid-modifier-extension-factory-functions","text":"Using @Composable builder functions for modifiers is not recommended, as they cause unnecessary recompositions. To avoid this, you should use Modifier.composed instead, as it limits recomposition to just the modifier instance, rather than the whole function tree. Composed modifiers may be created outside of composition, shared across elements, and declared as top-level constants, making them more flexible than modifiers that can only be created via a @Composable function call, and easier to avoid accidentally sharing state across elements. More info: Modifier extensions , Composed modifiers in Jetpack Compose by Jorge Castillo and Composed modifiers in API guidelines Related rule: twitter-compose:modifier-composable-check","title":"Avoid Modifier extension factory functions"}]}